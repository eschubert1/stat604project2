---
title: "Aging Brain — Matching-based Differential Expression (≥70 vs <70)"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    df_print: paged
editor_options:
  chunk_output_type: console
params:
  data_path: "data/brain.rda"   # Or set to "brain.rda"
  do_combat: TRUE             # Whether to perform ComBat batch correction
  n_top: 20                     # Number of “candidate” genes to select
  caliper: 0.2                  # Matching caliper (units: SD of PS logit)
---
```{r}
set.seed(20240924)
options(stringsAsFactors = FALSE)

# Install/load packages
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
  tidyverse, MatchIt, cobalt, broom, matrixStats, ggrepel,
  pheatmap, patchwork, knitr, kableExtra
)
# Optional batch correction
if (isTRUE(params$do_combat)) {
  if (!requireNamespace("sva", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
    BiocManager::install("sva", ask = FALSE, update = FALSE)
  }
  library(sva)
}

# Load data: priority is params path, then data/brain.rda, then project root
load("../data/brain.rda")

dim(expression); dim(arraymeta)
```
data preparation, combine technical repetition
```{r}
meta_raw <- as_tibble(arraymeta) %>%
  mutate(row_id = row_number(),
         region = case_when(
           region.ancg == 1 ~ "ANCg",
           region.cb   == 1 ~ "CB",
           region.dlpfc== 1 ~ "DLPFC",
           TRUE ~ NA_character_
         ),
         lab = case_when(
           lab.davis    == 1 ~ "Davis",
           lab.irvine   == 1 ~ "Irvine",
           lab.michigan == 1 ~ "Michigan",
           TRUE ~ NA_character_
         ),
         age70   = if_else(age >= 70, 1L, 0L),
         age_grp = if_else(age >= 70, ">=70", "<70"))

# Composite key: patient × region × lab × array version
meta_raw <- meta_raw %>%
  mutate(cluster_id = paste(patient, region, lab, arrayversion, sep = "_"))

# Align expression matrix with metadata rows
stopifnot(nrow(meta_raw) == nrow(expression))
rownames(expression) <- meta_raw$cluster_id

# For the same patient×region×lab×version, collapse technical replicates by column median
idx_by_cluster <- split(seq_len(nrow(expression)), meta_raw$cluster_id)
expr_collapsed <- do.call(
  rbind,
  lapply(idx_by_cluster, function(ix) matrixStats::colMedians(expression[ix, , drop = FALSE]))
)
cluster_ids <- names(idx_by_cluster)
rownames(expr_collapsed) <- cluster_ids

meta_collapsed <- meta_raw %>%
  group_by(cluster_id) %>%
  summarise(
    patient = first(patient),
    region  = first(region),
    lab     = first(lab),
    arrayversion = first(arrayversion),
    age     = first(age),
    sex     = first(sex),
    age70   = first(age70),
    age_grp = first(age_grp),
    n_reps  = n(),
    .groups = "drop"
  ) %>%
  filter(cluster_id %in% cluster_ids) %>%
  arrange(match(cluster_id, cluster_ids))
stopifnot(identical(meta_collapsed$cluster_id, rownames(expr_collapsed)))

probe_ids <- colnames(expr_collapsed)

# Align gene annotation with expression matrix
common_ids <- intersect(probe_ids, colnames(genemeta))

expr_use   <- expr_collapsed[, common_ids, drop = FALSE]
chrom_vec  <- genemeta["chrom", common_ids]
sym_vec    <- genemeta["sym", common_ids]

is_control <- grepl("^AFFX", common_ids, ignore.case = TRUE) | is.na(sym_vec)

expr_use <- expr_use[, !is_control, drop = FALSE]

gene_anno <- tibble(
  probe_id    = colnames(expr_use),
  gene_symbol = sym_vec[!is_control],
  chrom       = chrom_vec[!is_control]
)
cat("Number of samples (after collapsing):", nrow(expr_use),
    "; Number of genes (probes):", ncol(expr_use), "\n")
```
matching and difference analysis
```{r}
run_matching_for_region <- function(region_name, expr_mat, meta_df, caliper = 0.2, ratio = 1) {
  # Subset to the target region
  sel <- meta_df$region == region_name
  dat <- meta_df[sel, , drop = FALSE]
  if (!any(sel) || length(unique(dat$age70)) < 2 || min(table(dat$age70)) < 2) {
    message("Skip ", region_name, ": this region has too few samples or only one age group.")
    return(NULL)
  }
  expr_r <- expr_mat[sel, , drop = FALSE]

  # Ensure categorical covariates are factors
  dat$sex          <- factor(dat$sex)
  dat$lab          <- factor(dat$lab)
  dat$arrayversion <- factor(dat$arrayversion)

  # Propensity-score matching (nearest neighbor on logit PS) without replacement
  m.out <- MatchIt::matchit(
    age70 ~ sex + lab + arrayversion,
    data     = dat,
    method   = "nearest",
    distance = "logit",
    caliper  = caliper,
    ratio    = ratio,
    replace  = FALSE
  )
  md <- MatchIt::match.data(m.out)

  # Use cluster_id as the sample identifier
  matched_ids <- md$cluster_id
  expr_m <- expr_r[matched_ids, , drop = FALSE]

  # Build pairs by subclass; keep only subclasses containing both age groups
  md$pair_id <- md$subclass
  pairs <- split(md$cluster_id, md$pair_id)
  pairs <- Filter(function(ids) length(unique(md$age70[md$cluster_id %in% ids])) == 2, pairs)

  if (length(pairs) == 0) {
    warning("No valid pairs formed: ", region_name)
    return(list(region = region_name, m.out = m.out, md = md,
                expr_m = expr_m, pair_mat = NULL, stats = NULL))
  }

  # Construct a pair matrix (treat = age70==1, control = age70==0)
  pair_mat <- do.call(rbind, lapply(pairs, function(ids){
    i1 <- ids[md$age70[md$cluster_id %in% ids] == 1][1]
    i0 <- ids[md$age70[md$cluster_id %in% ids] == 0][1]
    c(treat = i1, control = i0)
  }))

  npairs <- nrow(pair_mat)

  # Compute paired differences per gene (Old − Young)
  diff_mat <- do.call(rbind, lapply(seq_len(npairs), function(j){
    expr_m[pair_mat[j, "treat"], ] - expr_m[pair_mat[j, "control"], ]
  }))

  # Mean difference, SD, t-statistic, p-values, and BH-FDR per probe
  mean_diff <- colMeans(diff_mat)
  sd_diff   <- apply(diff_mat, 2, sd)
  sd_diff[sd_diff == 0] <- NA_real_
  tstat <- mean_diff / (sd_diff / sqrt(npairs))
  pval  <- 2 * pt(-abs(tstat), df = max(npairs - 1, 1))

  res <- tibble(
    probe_id  = colnames(expr_m),
    mean_diff = as.numeric(mean_diff),
    t         = as.numeric(tstat),
    p         = as.numeric(pval),
    fdr       = p.adjust(pval, method = "BH"),
    region    = region_name,
    n_pairs   = npairs
  )
  list(region = region_name, m.out = m.out, md = md,
       expr_m = expr_m, pair_mat = pair_mat, stats = res)
}

# Run the matching-and-DE pipeline per region
regions <- c("ANCg", "CB", "DLPFC")
fits <- lapply(
  regions, run_matching_for_region,
  expr_mat = expr_use, meta_df = meta_collapsed,
  caliper = params$caliper
)
names(fits) <- regions

# Combine region-wise results and attach gene annotations
res_all <- bind_rows(lapply(fits, function(x) x$stats)) %>%
  left_join(gene_anno, by = c("probe_id" = "probe_id")) %>%
  relocate(gene_symbol, .after = probe_id)

# For each gene, keep the region with the largest absolute effect size
res_best_by_gene <- res_all %>%
  group_by(probe_id) %>%
  slice_max(order_by = abs(mean_diff), n = 1, with_ties = FALSE) %>%
  ungroup()

# Rank by |effect|, select top N, and label direction
topN <- res_best_by_gene %>%
  arrange(desc(abs(mean_diff))) %>%
  slice(1:params$n_top) %>%
  mutate(
    direction = if_else(mean_diff > 0, "Old Up (≥70 high)", "Old Down (≥70 low)"),
    abs_effect = abs(mean_diff)
  )

# Save to CSV
readr::write_csv(topN, "top20_genes_by_region.csv")
```
Top-N potential list
```{r}
topN %>%
  transmute(
    rank = row_number(),
    probe_id, gene_symbol, region, n_pairs,
    mean_diff = round(mean_diff, 3),
    abs_effect = round(abs_effect, 3),
    p = signif(p, 3),
    fdr = signif(fdr, 3),
    direction
  ) %>%
  knitr::kable(
    align = "rllllrrrrl",
    caption = "Top 20 candidate differential genes (ranked by |old−young|; best region is where the absolute effect is largest)"
  ) %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)

```
Visualizations
```{r}
library(tidyverse)
library(pheatmap)

# Robustly map raw numeric row names ("1","2",...) to the actual cluster_id in the region subset
.map_ids_to_cluster <- function(x, id_vec) {
  # If already a cluster_id (appears in id_vec), return as is
  hit <- x %in% id_vec
  out <- x
  # If looks like a pure number, treat it as row index within the region subset
  need_map <- !hit & grepl("^[0-9]+$", x)
  out[need_map] <- id_vec[as.integer(x[need_map])]
  out
}

# --- Key function: reconstruct matched pairs for a given region and align to expr_use / meta_collapsed ---
extract_pairs_by_region <- function(fit, region_name, expr_mat, meta_df) {
  stopifnot(!is.null(fit$m.out))
  mm <- fit$m.out$match.matrix
  if (is.null(mm)) stop("fit$m.out$match.matrix not found; matching may have failed or method does not provide match.matrix.")

  # Use the region subset consistent with matching to build a mapping row number → cluster_id
  dat_used <- meta_df %>% filter(region == region_name)
  id_vec   <- dat_used$cluster_id

  # Map match.matrix row names (treat) and column values (control) into cluster_id
  treat_ids_raw <- rownames(mm)
  control_ids_raw <- as.vector(t(mm))      # flatten to vector, later regroup
  control_ids_raw <- control_ids_raw[!is.na(control_ids_raw)]

  treat_ids_mapped   <- .map_ids_to_cluster(treat_ids_raw, id_vec)
  control_ids_mapped <- .map_ids_to_cluster(control_ids_raw, id_vec)

  # Expand into (treat, control) pairs row by row
  pair_df <- imap_dfr(as.data.frame(mm), function(col, k) {
    tibble(
      treat_id   = treat_ids_mapped,
      control_id = .map_ids_to_cluster(as.character(col), id_vec)
    ) %>% filter(!is.na(control_id))
  }) %>%
    distinct()

  if (nrow(pair_df) == 0) stop("No valid pairs formed (pair_df is empty).")

  matched_ids <- unique(c(pair_df$treat_id, pair_df$control_id))
  missing_in_expr <- setdiff(matched_ids, rownames(expr_mat))
  if (length(missing_in_expr) > 0) {
    stop("Matched samples not found in expression matrix:\n",
         paste(head(missing_in_expr, 10), collapse = ", "),
         if (length(missing_in_expr) > 10) sprintf(" ... and %d more", length(missing_in_expr)-10) else "")
  }

  # Expression matrix and metadata subset
  expr_m <- expr_mat[matched_ids, , drop = FALSE]
  md <- meta_df %>%
    filter(cluster_id %in% matched_ids) %>%
    mutate(
      age_grp = factor(age_grp, levels = c("<70", ">=70"))
    )

  # For grouped display in heatmap: generate pair_block order following treat order;
  # place all controls right before their treat
  treat_order <- unique(pair_df$treat_id)
  pair_df <- pair_df %>%
    mutate(pair_block = match(treat_id, treat_order))

  map_tbl <- bind_rows(
    pair_df %>% transmute(cluster_id = treat_id,   pair_block) %>% distinct(),
    pair_df %>% transmute(cluster_id = control_id, pair_block) %>% distinct()
  ) %>% distinct()

  md <- md %>% left_join(map_tbl, by = "cluster_id")

  # Column display order: for each treat, put its controls immediately before the treat
  col_order <- unlist(lapply(treat_order, function(tid) {
    c(pair_df$control_id[pair_df$treat_id == tid], tid)
  }))
  col_order <- unique(col_order[col_order %in% rownames(expr_m)])

  list(expr_m = expr_m, md = md, pair_df = pair_df, col_order = col_order)
}

# Top gene selection (from fit$stats)
pick_top_genes <- function(fit, n = 20, by = c("fdr", "abs_diff")) {
  by <- match.arg(by)
  st <- fit$stats
  if (by == "fdr") {
    st %>% arrange(fdr, desc(abs(mean_diff))) %>%
      slice_head(n = n) %>% pull(probe_id)
  } else {
    st %>% arrange(desc(abs(mean_diff))) %>%
      slice_head(n = n) %>% pull(probe_id)
  }
}

# Heatmap: keep pair order (no clustering of samples)
plot_heatmap_by_pair <- function(pairs_obj, top_genes, title = "Heatmap by Pairs") {
  expr_m  <- pairs_obj$expr_m
  md      <- pairs_obj$md
  ord_col <- pairs_obj$col_order

  if (length(top_genes) == 0 || length(ord_col) == 0) {
    message("No genes or no column order available for heatmap.")
    return(invisible(NULL))
  }

  expr_sub <- expr_m[ord_col, top_genes, drop = FALSE]
  expr_z   <- t(scale(t(expr_sub)))

  ann_col <- data.frame(
    AgeGroup  = md$age_grp[match(ord_col, md$cluster_id)],
    PairBlock = factor(md$pair_block[match(ord_col, md$cluster_id)])
  )
  rownames(ann_col) <- ord_col

  # draw via grid to make sure knitr captures it inside functions/loops
  p <- pheatmap::pheatmap(
    t(expr_z),
    cluster_rows  = TRUE,
    cluster_cols  = FALSE,
    annotation_col = ann_col,
    show_colnames = FALSE,
    main = title,
    silent = TRUE
  )
  grid::grid.newpage()
  grid::grid.draw(p$gtable)
  invisible(p)
}

# Paired line plots (if 1:k matching, one treat may have multiple control lines)
plot_paired_lines <- function(pairs_obj, gene, title = NULL) {
  expr_m  <- pairs_obj$expr_m
  pair_df <- pairs_obj$pair_df

  df <- pair_df %>%
    transmute(
      pair_id = paste0("T:", treat_id),
      y_young = expr_m[control_id, gene, drop = TRUE],
      y_old   = expr_m[treat_id,   gene, drop = TRUE]
    ) %>%
    pivot_longer(cols = c(y_young, y_old),
                 names_to = "grp", values_to = "expr") %>%
    mutate(age_grp = factor(ifelse(grp == "y_young", "<70", ">=70"),
                            levels = c("<70", ">=70")))

  ggplot(df, aes(x = age_grp, y = expr, group = pair_id, color = pair_id)) +
    geom_line(alpha = 0.5) +
    geom_point(size = 2) +
    stat_summary(aes(group = 1), fun = mean, geom = "line",
                 linewidth = 1.1, linetype = "dashed", color = "black") +
    stat_summary(aes(group = 1), fun = mean, geom = "point",
                 size = 3, color = "black") +
    theme_bw() +
    labs(
      title = title %||% paste0(gene, " (paired lines, old vs young)"),
      x = "Age group", y = "log expression"
    ) +
    theme(legend.position = "none")
}

# Distribution of differences (Old - Young), per pair or per-treat average
plot_diff_distribution <- function(pairs_obj, gene, mode = c("per_pair","per_treat_mean"),
                                   title = NULL) {
  mode   <- match.arg(mode)
  expr_m <- pairs_obj$expr_m
  pair_df <- pairs_obj$pair_df

  diffs <- pair_df %>%
    transmute(
      treat_id,
      diff = expr_m[treat_id, gene, drop = TRUE] -
             expr_m[control_id, gene, drop = TRUE]
    )

  if (mode == "per_treat_mean") {
    diffs <- diffs %>%
      group_by(treat_id) %>%
      summarise(diff = mean(diff, na.rm = TRUE), .groups = "drop")
  }

  ggplot(diffs, aes(x = diff)) +
    geom_histogram(bins = 20, color = "white") +
    geom_vline(xintercept = 0, linetype = "dashed") +
    theme_bw() +
    labs(
      title = title %||% paste0(gene, " differences: Old - Young (", mode, ")"),
      x = "Difference in log expression", y = "Count"
    )
}

# Wrapper: render all pair-level visualizations for a region
render_pair_views_for_region <- function(fit, region_name, expr_mat, meta_df,
                                         top_n = 20, top_by = "fdr",
                                         example_probe = NULL) {
  pairs_obj <- extract_pairs_by_region(fit, region_name, expr_mat, meta_df)
  top_genes <- pick_top_genes(fit, n = top_n, by = top_by)

  plot_heatmap_by_pair(
    pairs_obj, top_genes,
    title = paste0(region_name, ": Top ", top_n, " by ", top_by, " (paired order)")
  )

  if (is.null(example_probe)) example_probe <- top_genes[1]
  print(plot_paired_lines(
    pairs_obj, gene = example_probe,
    title = paste0(region_name, ": ", example_probe, " (paired lines)")
  ))
  print(plot_diff_distribution(
    pairs_obj, gene = example_probe, mode = "per_pair",
    title = paste0(region_name, ": ", example_probe, " diffs (per pair)")
  ))
  print(plot_diff_distribution(
    pairs_obj, gene = example_probe, mode = "per_treat_mean",
    title = paste0(region_name, ": ", example_probe, " diffs (per treat mean)")
  ))

  invisible(list(pairs = pairs_obj, top_genes = top_genes, example_probe = example_probe))
}


```

```{r}
# --- demo: actually render plots for one region, e.g., DLPFC ---

# 1) Pre-check: by this stage you should already have fits / expr_use / meta_collapsed
stopifnot(
  exists("fits"), exists("expr_use"), exists("meta_collapsed"),
  !is.null(fits[["DLPFC"]]), !is.null(fits[["DLPFC"]]$stats)
)

# 2) Build the paired object
pairs_obj <- extract_pairs_by_region(
  fit = fits[["DLPFC"]],
  region_name = "DLPFC",
  expr_mat = expr_use,
  meta_df  = meta_collapsed
)

# 3) Select top genes (by FDR or absolute effect size)
tg <- pick_top_genes(fits[["DLPFC"]], n = 12, by = "fdr")

# 4) Heatmap (function already uses grid.draw internally)
plot_heatmap_by_pair(pairs_obj, tg, title = "DLPFC: Top 12 by FDR (paired order)")

# 5) Choose one gene for paired line plots and difference distributions
g <- tg[1]

# ggplot objects must be printed explicitly to show up in R Markdown
print(plot_paired_lines(pairs_obj, gene = g,
                        title = paste0("DLPFC: ", g, " (paired lines)")))
print(plot_diff_distribution(pairs_obj, gene = g, mode = "per_pair",
                             title = paste0("DLPFC: ", g, " diffs (per pair)")))
print(plot_diff_distribution(pairs_obj, gene = g, mode = "per_treat_mean",
                             title = paste0("DLPFC: ", g, " diffs (per treat mean)")))
```

